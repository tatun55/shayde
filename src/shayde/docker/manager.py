"""Docker container manager for Playwright."""

from __future__ import annotations

import logging
import os
import shutil
import subprocess
import sys
import tempfile
import time
from pathlib import Path
from typing import TYPE_CHECKING, Dict, Optional
from urllib.parse import urlparse

from jinja2 import Template

if TYPE_CHECKING:
    from shayde.config.schema import ShaydeConfig, PlatformType

logger = logging.getLogger(__name__)

# Docker compose template
COMPOSE_TEMPLATE = """# Shayde Playwright Container
# Auto-generated by Shayde

services:
  playwright:
    image: {{ image }}
    container_name: {{ container_name }}
    command: npx -y playwright@{{ playwright_version }} run-server --port {{ ws_port }} --host 0.0.0.0
    ports:
      - "{{ ws_port }}:{{ ws_port }}"
    extra_hosts:
{% for host in extra_hosts %}
      - "{{ host.hostname }}:{{ host.ip }}"
{% endfor %}
      - "host.docker.internal:host-gateway"
    dns:
      - 8.8.8.8
{% if volumes %}
    volumes:
{% for volume in volumes %}
      - "{{ volume }}"
{% endfor %}
{% endif %}
{% if environment %}
    environment:
{% for key, value in environment.items() %}
      - "{{ key }}={{ value }}"
{% endfor %}
{% endif %}
"""

# Platform-specific CSS for font override
PLATFORM_CSS: Dict[str, str] = {
    "neutral": """
        * {
            font-family: 'Noto Sans CJK JP', 'Noto Sans JP', sans-serif !important;
        }
    """,
    "mac": """
        * {
            font-family: 'Source Han Sans JP', 'Hiragino Sans', 'Hiragino Kaku Gothic ProN', sans-serif !important;
        }
    """,
    "windows": """
        * {
            font-family: 'BIZ UDGothic', 'Yu Gothic', 'Meiryo', sans-serif !important;
        }
    """,
}


def get_package_docker_dir() -> Path:
    """Get the docker directory in the shayde package."""
    # First check if we're in development mode (running from source)
    source_dir = Path(__file__).parent.parent.parent.parent.parent / "docker"
    if source_dir.exists():
        return source_dir

    # Otherwise, use the installed package location
    import shayde
    package_dir = Path(shayde.__file__).parent.parent.parent / "docker"
    return package_dir


class DockerManager:
    """Manages Docker Playwright container lifecycle."""

    def __init__(self, config: "ShaydeConfig"):
        self.config = config
        self._compose_file: Optional[Path] = None
        self._docker_bin = self._find_docker()
        self._platform: Optional[str] = None

    def _find_docker(self) -> str:
        """Find Docker binary."""
        # macOS Docker Desktop path
        macos_path = "/Applications/Docker.app/Contents/Resources/bin/docker"
        if Path(macos_path).exists():
            return macos_path

        # System PATH
        docker_path = shutil.which("docker")
        if docker_path:
            return docker_path

        raise RuntimeError("Docker not found. Please install Docker Desktop.")

    def set_platform(self, platform: "PlatformType") -> None:
        """Set the platform for font simulation."""
        self._platform = platform

    def get_platform(self) -> str:
        """Get current platform setting."""
        return self._platform or self.config.fonts.platform

    def get_platform_css(self) -> str:
        """Get CSS for current platform's fonts."""
        platform = self.get_platform()
        return PLATFORM_CSS.get(platform, PLATFORM_CSS["neutral"])

    def _get_extra_hosts(self) -> list:
        """Generate extra_hosts list for docker-compose."""
        hosts = []

        # Add host from APP_URL if available
        if self.config.app.base_url:
            parsed = urlparse(self.config.app.base_url)
            if parsed.hostname and parsed.hostname not in ("localhost", "127.0.0.1"):
                hosts.append({
                    "hostname": parsed.hostname,
                    "ip": "host-gateway",
                })

        return hosts

    def _get_volumes(self) -> list:
        """Get volume mounts for container."""
        volumes = []

        # Mount custom fonts directory if specified
        if self.config.fonts.custom_fonts_dir:
            fonts_path = Path(self.config.fonts.custom_fonts_dir).expanduser()
            if fonts_path.exists():
                volumes.append(f"{fonts_path}:/usr/share/fonts/custom:ro")

        return volumes

    def _get_environment(self) -> Dict[str, str]:
        """Get environment variables for container."""
        env = {}

        # Set platform for font configuration
        platform = self.get_platform()
        env["SHAYDE_PLATFORM"] = platform

        return env

    def _get_image_name(self) -> str:
        """Get the Docker image name to use."""
        if self.config.docker.use_custom_image:
            return f"{self.config.docker.image_name}:latest"
        return f"mcr.microsoft.com/playwright:v{self.config.docker.playwright_version}-noble"

    def _generate_compose_file(self) -> Path:
        """Generate docker-compose.yml from template."""
        template = Template(COMPOSE_TEMPLATE)

        content = template.render(
            image=self._get_image_name(),
            playwright_version=self.config.docker.playwright_version,
            container_name=self.config.docker.container_name,
            ws_port=self.config.docker.ws_port,
            extra_hosts=self._get_extra_hosts(),
            volumes=self._get_volumes(),
            environment=self._get_environment(),
        )

        # Write to temp directory
        compose_dir = Path(tempfile.gettempdir()) / "shayde"
        compose_dir.mkdir(parents=True, exist_ok=True)

        compose_file = compose_dir / f"{self.config.docker.container_name}-compose.yml"
        compose_file.write_text(content)

        self._compose_file = compose_file
        return compose_file

    def _run_docker(self, *args: str, check: bool = True) -> subprocess.CompletedProcess:
        """Run docker command."""
        cmd = [self._docker_bin, *args]
        logger.debug(f"Running: {' '.join(cmd)}")
        return subprocess.run(cmd, capture_output=True, text=True, check=check)

    def _run_compose(self, *args: str, check: bool = True) -> subprocess.CompletedProcess:
        """Run docker compose command."""
        if not self._compose_file:
            self._generate_compose_file()

        cmd = [self._docker_bin, "compose", "-f", str(self._compose_file), *args]
        logger.debug(f"Running: {' '.join(cmd)}")
        return subprocess.run(cmd, capture_output=True, text=True, check=check)

    def is_docker_running(self) -> bool:
        """Check if Docker daemon is running."""
        try:
            result = self._run_docker("info", check=False)
            return result.returncode == 0
        except FileNotFoundError:
            return False

    def start_docker(self) -> bool:
        """Start Docker Desktop (macOS)."""
        if self.is_docker_running():
            return True

        if sys.platform == "darwin":
            logger.info("Starting Docker Desktop...")
            subprocess.run(["open", "-a", "Docker"], check=False)

            # Wait for Docker to start
            for _ in range(30):
                time.sleep(1)
                if self.is_docker_running():
                    logger.info("Docker Desktop started")
                    return True

            logger.error("Docker Desktop failed to start")
            return False

        logger.error("Docker daemon is not running")
        return False

    def is_image_built(self) -> bool:
        """Check if custom image is built."""
        if not self.config.docker.use_custom_image:
            return True

        result = self._run_docker(
            "images", "-q", self._get_image_name(),
            check=False,
        )
        return bool(result.stdout.strip())

    def build_image(self, force: bool = False) -> bool:
        """Build the custom Shayde Docker image with fonts."""
        if not self.config.docker.use_custom_image:
            logger.info("Custom image disabled, using official Playwright image")
            return True

        if self.is_image_built() and not force:
            logger.info(f"Image {self._get_image_name()} already exists")
            return True

        docker_dir = get_package_docker_dir()
        dockerfile = docker_dir / "Dockerfile"

        if not dockerfile.exists():
            logger.error(f"Dockerfile not found at {dockerfile}")
            return False

        logger.info(f"Building image {self._get_image_name()}...")
        logger.info("This may take a few minutes (downloading fonts)...")

        result = self._run_docker(
            "build",
            "-t", self._get_image_name(),
            "-f", str(dockerfile),
            str(docker_dir),
            check=False,
        )

        if result.returncode != 0:
            logger.error(f"Failed to build image: {result.stderr}")
            return False

        logger.info(f"Image {self._get_image_name()} built successfully")
        return True

    def is_container_running(self) -> bool:
        """Check if Playwright container is running."""
        result = self._run_docker(
            "ps", "-q", "-f", f"name={self.config.docker.container_name}",
            check=False,
        )
        return bool(result.stdout.strip())

    def start(self) -> bool:
        """Start the Playwright container."""
        # Ensure Docker is running
        if not self.start_docker():
            return False

        # Build custom image if needed
        if self.config.docker.use_custom_image:
            if not self.build_image():
                logger.warning("Failed to build custom image, falling back to official image")
                # Temporarily disable custom image
                self.config.docker.use_custom_image = False

        # Check if already running
        if self.is_container_running():
            logger.info(f"Container {self.config.docker.container_name} already running")
            return True

        # Generate compose file and start
        self._generate_compose_file()

        logger.info(f"Starting container {self.config.docker.container_name}...")
        result = self._run_compose("up", "-d", check=False)

        if result.returncode != 0:
            logger.error(f"Failed to start container: {result.stderr}")
            return False

        # Wait for Playwright server to be ready
        logger.info("Waiting for Playwright server...")
        for _ in range(30):
            time.sleep(0.5)
            if self._check_playwright_ready():
                logger.info("Playwright server ready")
                return True

        logger.warning("Playwright server may not be ready")
        return True

    def _check_playwright_ready(self) -> bool:
        """Check if Playwright WebSocket server is responding."""
        import socket

        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            result = sock.connect_ex(("localhost", self.config.docker.ws_port))
            sock.close()
            return result == 0
        except Exception:
            return False

    def stop(self) -> bool:
        """Stop the Playwright container."""
        if not self.is_container_running():
            logger.info(f"Container {self.config.docker.container_name} not running")
            return True

        logger.info(f"Stopping container {self.config.docker.container_name}...")
        result = self._run_docker(
            "stop", self.config.docker.container_name,
            check=False,
        )

        if result.returncode != 0:
            logger.error(f"Failed to stop container: {result.stderr}")
            return False

        return True

    def get_ws_url(self) -> str:
        """Get WebSocket URL for Playwright connection."""
        return f"ws://localhost:{self.config.docker.ws_port}"

    def get_status(self) -> Dict[str, object]:
        """Get container status information."""
        return {
            "container_name": self.config.docker.container_name,
            "running": self.is_container_running(),
            "docker_running": self.is_docker_running(),
            "ws_url": self.get_ws_url(),
            "playwright_version": self.config.docker.playwright_version,
            "image": self._get_image_name(),
            "image_built": self.is_image_built(),
            "platform": self.get_platform(),
        }

    def get_logs(self, tail: int = 50) -> str:
        """Get container logs."""
        result = self._run_docker(
            "logs", "--tail", str(tail), self.config.docker.container_name,
            check=False,
        )
        return result.stdout + result.stderr
